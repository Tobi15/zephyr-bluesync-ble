{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BlueSync for Zephyr RTOS","text":"<p>BlueSync is a lightweight and energy-efficient time synchronization protocol designed for Bluetooth Low Energy (BLE) Mesh networks. It enables accurate, multi-hop synchronization in resource-constrained environments such as linear sensor networks deployed in tunnels or industrial facilities.</p> <p>This documentation describes the protocol design and implementation within the Zephyr RTOS framework.</p>"},{"location":"#documentation-sections","title":"\ud83d\udcda Documentation Sections","text":"<ul> <li> <p>\ud83e\udde0 Conception:   Learn about the motivation, architecture, packet format, and state machines that form the foundation of BlueSync.</p> </li> <li> <p>\ud83d\udee0 Implementation:   Dive into the technical details of how BlueSync is integrated with Zephyr, including BLE usage, timestamping, drift correction, and more.</p> </li> </ul>"},{"location":"#api-documentation","title":"\ud83d\udd0d API Documentation","text":"<p>The full API reference generated with Doxygen is available here:</p> <p>\ud83d\udc49 View BlueSync API Docs</p>"},{"location":"#reference","title":"\ud83d\udcd6 Reference","text":"<p>This project is based on the following work:</p> <p>A. A. Ghosh and R. Sridhar, \"BlueSync: BLE-Based Time Synchronization Using Broadcast Advertisements\", 2021 IEEE 5th World Forum on Internet of Things (WF-IoT), pp. 52\u201357, 2021. DOI: 10.1109/WF-IoT51360.2021.9555832</p> <p>This project is developed and maintained by @Tobi15.</p>"},{"location":"conception/","title":"Conception of BlueSync in Zephyr RTOS","text":"<p>The design of BlueSync in Zephyr RTOS was driven by the need for an efficient, scalable, and accurate time synchronization protocol tailored to the constraints of BLE Mesh in linear sensor deployments (e.g., tunnels).</p>"},{"location":"conception/#objectives","title":"Objectives","text":"<ul> <li>Achieve microsecond-level synchronization accuracy over BLE Mesh.</li> <li>Support low-power, resource-constrained devices.</li> <li>Use BLE Extended Advertising for long-range, non-connectable broadcasts.</li> <li>Enable multi-hop time propagation across a linear network.</li> <li>Integrate seamlessly with Zephyr RTOS modules and drivers.</li> </ul>"},{"location":"conception/#key-design-principles","title":"Key Design Principles","text":"<ul> <li> <p>Centralized Authority Node   A gateway node with NTP or GPS access serves as the synchronization anchor.</p> </li> <li> <p>One-Way Sync   Clients passively receive extended advertisements carrying timestamps.</p> </li> <li> <p>Precise Hardware Timestamping   Clients use hardware timers (e.g., RTC, TIMER2) to timestamp sync packet arrival.</p> </li> <li> <p>Linear Regression Drift Correction   Clock offset and drift are estimated using linear regression over multiple timestamp pairs.</p> </li> <li> <p>Chained Multi-Hop Propagation   Downstream nodes receive re-broadcasted sync packets and synchronize in turn.</p> </li> </ul>"},{"location":"conception/#bluesync-packet-format","title":"BlueSync Packet Format","text":"Field Size Description <code>round_id</code> 1 byte ID for the sync round, incremented by Authority <code>slot_idx</code> 1 byte Optional slot index (can be used for future use) <code>timestamp</code> 8 bytes Master time in microseconds (Unix epoch)"},{"location":"conception/#state-machine-overview","title":"State Machine Overview","text":""},{"location":"conception/#authority-node-gateway","title":"Authority Node (Gateway)","text":"<ul> <li><code>STOP</code>: Initial idle state.</li> <li><code>ADV</code>: Starts a sync round, increments <code>round_id</code>, advertises a burst of sync packets, returns to <code>STOP</code>.</li> </ul>"},{"location":"conception/#client-node-sensor","title":"Client Node (Sensor)","text":"<ul> <li><code>SCAN_WAIT_FOR_SYNC</code>: Listens for sync packets.</li> <li><code>SYNC</code>: Collects timestamp pairs.</li> <li><code>UPDATE</code>: Computes and applies clock correction using regression.</li> <li><code>ADV</code>: Optionally rebroadcasts sync packet; returns to <code>SCAN_WAIT_FOR_SYNC</code>.</li> </ul>"},{"location":"conception/#synchronization-flow","title":"Synchronization Flow","text":"<ol> <li>Authority broadcasts sync message with timestamp.</li> <li>Clients timestamp the reception and store local/master pairs.</li> <li>After receiving N messages, clients estimate slope and offset.</li> <li>Logical time is corrected using:</li> </ol> <pre><code>logical_time(t) = slope * local_time(t) + offset\n</code></pre> <ol> <li>Clients forward sync message to downstream nodes.</li> <li>The process repeats down the linear topology.</li> </ol>"},{"location":"implementation/","title":"Implementation of BlueSync in Zephyr RTOS","text":"<p>The BlueSync protocol is implemented as a lightweight module in Zephyr RTOS using BLE Extended Advertising and hardware timers. It enables precise time synchronization across BLE Mesh sensor nodes with minimal overhead.</p>"},{"location":"implementation/#ble-communication","title":"BLE Communication","text":"<ul> <li>Authority node uses <code>bt_le_ext_adv_start()</code> to send sync packets.</li> <li>Client nodes use <code>bt_le_scan_start()</code> with filters to receive sync messages.</li> <li>Packets are sent as non-connectable extended advertisements, minimizing power and connection setup overhead.</li> </ul>"},{"location":"implementation/#timestamping","title":"Timestamping","text":"<ul> <li>Reception timestamps are captured using RTC or TIMER2 at the radio callback level.</li> <li>Timestamps are stored in microseconds, based on a 32.768 kHz or higher resolution timer.</li> <li><code>k_uptime_ticks()</code> or hardware timer APIs are used, depending on platform.</li> </ul>"},{"location":"implementation/#linear-regression","title":"Linear Regression","text":"<p>Each client performs linear regression to compute the best-fit slope and offset between master and local clocks.</p> <ul> <li>Inputs: <code>N</code> pairs of <code>(local_time, master_time)</code></li> <li>Computation:</li> </ul> <p>```c   slope  = cov(x, y) / var(x);   offset = mean(y) - slope * mean(x);</p> <ul> <li>If regression is successful (low error), client applies the calculated:</li> <li>Offset: directly adjusts logical time.</li> <li>Slope: stored for future drift correction.</li> <li>If regression fails:</li> <li>Client resets sync state.</li> <li>Returns to SCAN_WAIT_FOR_SYNC.</li> </ul>"},{"location":"implementation/#logical-time-correction","title":"Logical Time Correction","text":"<p>To get synchronized time on a client node:</p> <pre><code>uint64_t get_logical_time_us() {\n    return slope * local_time() + offset;\n}\n</code></pre> <ul> <li><code>local_time()</code> is obtained from RTC or uptime ticks.</li> <li>Offset and slope are applied dynamically without modifying the actual hardware clock.</li> </ul>"},{"location":"implementation/#multi-hop-propagation","title":"Multi-Hop Propagation","text":"<ul> <li>After a successful sync update, a client rebroadcasts the sync packet.</li> <li>Downstream nodes use this rebroadcast to perform the same sync routine.</li> <li>This creates a chained propagation down the linear network.</li> </ul>"},{"location":"implementation/#integration-with-zephyr","title":"Integration with Zephyr","text":"<ul> <li>Timers: Zephyr\u2019s <code>counter</code> driver is used to timestamp sync events.</li> <li>Bluetooth: Uses Zephyr\u2019s <code>bt_le_ext_adv</code> and <code>bt_le_scan</code> APIs.</li> <li>Shell interface (optional): For triggering sync or printing sync stats.</li> <li>Kconfig options: Allow enabling/disabling sync features, adjusting sample count, etc.</li> </ul>"},{"location":"implementation/#logging-and-debug","title":"Logging and Debug","text":"<ul> <li>Verbose logging with <code>CONFIG_BLUESYNC_LOG_LEVEL</code></li> <li>Each sync round stores metadata:</li> <li><code>round_id</code></li> <li><code>offset</code>, <code>slope</code></li> <li>Sync quality metrics (e.g., error, sample count)</li> </ul> <p>Logs can be dumped to CSV or shell output for validation.</p>"},{"location":"kconfig/","title":"Kconfig Options","text":""},{"location":"kconfig/#bluesync_support","title":"<code>BLUESYNC_SUPPORT</code>","text":"<ul> <li>Type: <code>bool \"BlueSync support\"</code></li> <li>Default: <code>n</code></li> </ul>"},{"location":"kconfig/#bluesync_used_in_mesh","title":"<code>BLUESYNC_USED_IN_MESH</code>","text":"<ul> <li>Type: <code>bool \"Use BlueSync in BLE Mesh mode\"</code></li> <li>Default: <code>y</code></li> </ul>"},{"location":"kconfig/#bluesync_thread_stack_size","title":"<code>BLUESYNC_THREAD_STACK_SIZE</code>","text":"<ul> <li>Type: <code>hex \"BlueSync thread stack size\"</code></li> <li>Default: <code>0x800</code></li> </ul>"},{"location":"kconfig/#bluesync_thread_priority","title":"<code>BLUESYNC_THREAD_PRIORITY</code>","text":"<ul> <li>Type: <code>int \"BlueSync thread priority\"</code></li> <li>Default: <code>5</code></li> </ul>"},{"location":"kconfig/#bluesync_adv_int_ms","title":"<code>BLUESYNC_ADV_INT_MS</code>","text":"<ul> <li>Type: <code>int \"Burst packet interval (ms)\"</code></li> <li>Default: <code>200</code></li> </ul>"},{"location":"kconfig/#bluesync_slots_in_burst","title":"<code>BLUESYNC_SLOTS_IN_BURST</code>","text":"<ul> <li>Type: <code>int \"Timeslots per burst\"</code></li> <li>Default: <code>16</code></li> </ul>"},{"location":"kconfig/#bluesync_burst_windows_size","title":"<code>BLUESYNC_BURST_WINDOWS_SIZE</code>","text":"<ul> <li>Type: <code>int \"Number of bursts used for regression\"</code></li> <li>Default: <code>4</code></li> </ul>"},{"location":"kconfig/#bluesync_test_babblesim_support","title":"<code>BLUESYNC_TEST_BABBLESIM_SUPPORT</code>","text":"<ul> <li>Type: <code>bool \"Enable BabbleSim support\"</code></li> <li>Default: <code>n</code></li> </ul>"},{"location":"kconfig/#bluesync_test_babblesim_path","title":"<code>BLUESYNC_TEST_BABBLESIM_PATH</code>","text":"<ul> <li>Type: <code>string \"Path of the babblesim output file\"</code></li> </ul>"}]}